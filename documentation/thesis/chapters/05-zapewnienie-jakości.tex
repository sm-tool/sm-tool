\chapter{Zapewnienie jakości}

\section{Definition of done}
Podczas tworzenia naszego projektu posługiwaliśmy się zdefiniowanymi przez nas zasadami \emph{Definition of done}. Pierwszą z nich było sprawdzenie, czy nowa implementacja funkcjonalności działa zgodnie z założeniami.
W tym celu w kodzie zostały napisane testy automatyczne, które musiały przejśc pomyślnie. Funkcjonalność sprawdzaliśmy również wykonując testy manualne. Kolejną zasadą było pisanie i utrzymywanie czystego kodu. W tym celu używaliśmy automatycznego
formatowania kodu i sprawdzania commitów, które umożliwiło popularne narzędzie Git hook - Husky. Następnie każdy pull request musiał zostać zatwierdzony sprawdzony i przetestowany przez innego członka zespołu developerskiego, w celu potwierdzenia
poprawnego działania zmian. Kolejnym krokiem było uzupełnienie lub modyfikacja wewnętrznej dokumentacji projektu.

Dzięki zastosowaniu \emph{Definition of done} w naszym projekcie, każdy członek zespołu miał jasno zdefiniowane kryteria, które musi spełniać poszczególne zadanie, aby mogło zostać zaakceptowane i oznaczone jako zakończone. Takie podejście znacząco poprawiło
jakość aplikacji oraz komfort pracy zespołowej.

\section{Scrum}
Jakość kodu została także zapewniona poprzez korzystanie z metodyki \emph{Scrum}. W jej ramach byliśmy podzieleni na konkretne role takie jak Product Owner, odpowiedzialny za definiowanie wymagań oraz priorytetów, a także zespół developerski, który skupił się
głównie na implementacji kodu aplikacji. Pracowaliśmy w systemie 2 tygodniowych sprintów. Każdy sprint rozpoczynał się planowaniem sprintu, podczas którego zadania były rozdzielane na poszczególne osoby oraz uzupełniane w Backlogu. W trakcie sprintu, w zależności od dostępności i potrzeb developerzy spotykali się ze sobą
na krótkim, zdalnym spotkaniu w celu aktualizacji postępów. Następnie przychodziła kolei na retrospektywę i zakończenie sprintu, które polegało na podsumowaniu naszej 2 tygodniowej pracy, omówieniu tego co z wcześniej wyznaczonych celów udało się osiągnąć, ale także to co się nie udało. Podczas retrospektywy
przeprowadzaliśmy analizę co jest do poprawy w naszym sposobie działania oraz to co działa poprawnie. W celu rozplanowywania
zadań na dany sprint korzystaliśmy z platformy \emph{Github Issues}, która umożliwiała nam ustawianie priorytetów oraz zamykanie ukończonych zadań. Podczas spotkań używaliśmy darmowych narzędzi takich jak tablice internetowe: \emph{Miro} oraz \emph{Figma}. Komunikowaliśmy się oraz przesyłaliśmy między sobą materiały
za pomocą komunikatorów: \emph{Discord} i \emph{Google Meet}. Umożliwiło nam to szybkie rozwiązywanie napotkanych problemów oraz bieżące konsultacje w zespole.

Zastosowanie metodyki \emph{Scrum} pozwoliło nam na ułatwienie organizacji pracy, lepsze zarządzanie czasem oraz komunikację wewnątrz zespołu. Regularne spotkania pozwoliły nam na łatwiejsze definiowanie i priorytezowanie zadań, a także na szybkie reagowanie na pojawiające się problemy.

\section{Czysty kod}
W ramach zapewnienia jakości kodu, podczas implementacji kierowaliśmy się zasadami pisania czystego kodu. Zastosowaliśmy jednoznaczne nazywnictwo, które umożliwiło na jasne określenie przeznaczenia danej funkcji, zmiennej lub klasy na podstawie nazwy.
Kod podzieliliśmy na moduły takie jak: kontrolery, repozytoria, serwisy oraz DTO. Dzięki temu każdy moduł odpowiadał za dane zadanie. Unikaliśmy powtórzeń tego samego kodu w różnych miejscach projektu. W tym celu zastosowaliśmy mechanizmy dziedziczenia oraz pisania funkcji globalnych.

W projekcie wykorzystaliśmy również automatyzację utrzymywania jakości kodu, poprzez wprowadzenie pewnych narzędzi. Pierwszym z nich było lintowanie, czyli użycie narzędzia, które automatycznie weryfikowało poprawność kodu z wcześniej określonymi zasadami formatowania takimi jak wielkość wcięcia, czy długość linijki kodu.
W celu zapewnienia czystego kodu, zastosowaliśmy również narzędzie Git Hooks - \emph{Husky}. Umożliwiło to automatyczne sprawdzanie kodu zanim zostało zatwierdzone poprzez system kontroli wersji. Wszystkie te praktyki i narzędzia znacząco przyczyniły się do poprawy czystości kodu naszej aplikacji.

\section{Code review}
W celu zapewnienia jakości kodu na późniejszym etapie, zastosowaliśmy \emph{Code review}. Każdy developer w naszym zepsole pracował na wcześniej stworzonej przez siebie gałęzi, którą po zaimplementowaniu odpowiedniej funkcjonalności, mógł przyłączyć do głównej gałęzi \emph{main}. W tym celu musiał stworzyć \emph{pull request},
który musiał zostać zaakceptowany przez conajmniej jednego członka zespołu po dodatkowej analizie oraz testowaniu zmian na danej gałęzi. Umożliwiło to nie tylko poprawę jakości kodu, ale także dzielenie się wiedzą w zespole. W celu robienia \emph{Code review} zastosowaliśmy \emph{Github Pull Request}, umożliwiło bieżące dodawanie komentarzy przez sprawdzającego, tak aby
autor zmian mógł sprawnie poprawić to co nie działało, albo po prostu potrzebowało zmian. Każdy recenzent używał swojej checklisty, na której znajdowały się m.in. pytania czy kod jest zgodny z zasadami czystego kodu, to czy jest brak błędów oraz to czy kod działa poprawnie. Dzięki zastosowaniu takiego podejścia w naszym kodzie znacząco spadła ilość błędów, została wprowadzona standaryzacja oraz każdy
członek zespołu miał możliwość nauczenia się nowych funkcjonalności podczas sprawdzania kodu.

\section{Testy jednostkowe}
Testy jednostkowe były kluczowe w zapewnieniu jakości kodu. Pozwoliły one na sprawdzenie poprawności działania kodu. Testy napisaliśmy zgodnie z dobrymi praktykami, dzięki czemu mieliśmy pewność, że każdy moduł działa poprawnie w izolacji. Testy jednostkowe zostały zaimplementowane przy pomocy frameworka JUnit 5, natomiast do mockowania wykorzystaliśmy bibliotekę Mockito, co pozwoliło na izolację testowanych funkcji.

\section{Testy manualne}
Kolejnym typem testów zapewniającym jakość projektu były testy manualne. Były one przeprowadzane przez developerów na oddzielnych gałęziach jeszcze przed połączeniem ich z gałęzią \emph{main}. Polegały one na ręcznym sprawdzeniu funkcjonalności kodu m.in. przy zastosowaniu takich narzędzi jak \emph{Postman}.
Autor po każdej aktualizacji, sprawdzał czy endpointy zwracają poprawne dane w odpowiedzi na konkretne zapytania, takie jak: \emph{GET, PUT, POST}. Taki test również zawierał weryfikację obsługi błędów, czli sprawdzenie czy użytkownik otrzymuje poprawny kod w momencie wystąpienia danego typu błędu. Tego typu testy pozwoliły
na weryfikację działania kodu w prawdziwym środowisku.

\section{Testy akceptacyjne}